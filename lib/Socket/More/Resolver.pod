=head1 NAME

Socket::More::Resolver - Asynchronous DNS resolving

=head1 SYNOPSIS

Automatic Event Loop Integration and support

  use v5.36;

  use AnyEvent; # or EV, IO::Async

  use Socket::More::Resolver; 
  
  getaddrinfo("www.google.com", 0, {},
    sub {
      # got results
    },
    sub {
      # got an error
      say gai_strerror $_[0];
    }


  # Normal Event loop setup
  my $cv=AE::cv;
  $cv->recv;

=head1 DESCRIPTION

An asynchronous DNS resolution package use your platforms C<getaddrinfo>  and
C<getnameinfo> routines. Automatically integrates into supported event loops
and also provides a polling (non blocking) API.

Unlike the same named routines in core the L<Socket> module, results and errors
are reported back via callbacks and not return values.

Also the C<getaddrinfo> routine supports array 'struct' fields for hints.
Results will also be returned in this format instead of a has when used.

When integrated with
event loops these are executed in a asynchronous manner

Uses pure Perl unless L<Socket::More::Lookup> in available, (part of
L<Socket::More>). In this case the lookup routines are used from that module
(less memory, faster).

=head1 USAGE (with or without an event loop)

The resolver is designed to work with or without an event loop:

=over 

=item Using without an event loop

  use Socket::More::Resolver (options);

=item Using with an eventloop

  use Socket::More::Resolver::DRIVER::PACKAGE (options);

  eg
      use Socket::More::Resolver::AE;           #AnyEvent
      use Socket::More::Resolver::IO::Async;    #IO::Async
      use Socket::More::Resolver::Mojo::IOLoo;  # Mojo

=back

In either case, this will automatically start the worker pool, if it hasn't
already been started. 

Using the supported event loops, the above will automatically integrate the
required IO monitoring. Please refer the docs of the builtin drivers for
details/differences on their usage.

TODO: fix mojo default loop


=head2 Options

There a couple of options which influence resolver. These are specified as
import options in either the event loop driver or non event loop case:


=over
=item no_export

  no_export=>1

When set to a true value, prevents the exporting of symbols into the target
namespace. Useful when making a wrapper class/driver for event loops that want
to use the same names

=item max_worker
  
  max_worker=>$number

This item sets the maximum number of workers to spawn. The default is 4.

=item prefork

  prefork=>1||0

Start all workers at launch instead of as needed.

=head1 Adding other event loops

If you need to add an event loop which isn't directly supported, the easiest
way is to look at the code for one of the existing drivers. The basic idea is
to use the reexporting facility in L<Export::These> to pass through import
options to L<Socket::More::Resolver>. The name of thedriver is completely up to
the author.

There is no class/OO/mixin requirements from the resolver, so the driver can be
written based around your event loop API and inheritance structure.


=head2 API



=head2 Supported Event Loops

=over

=item AnyEvent

=back

=head1 How it works (High Level)

When the L<Socket::More::Resolver> package is loaded for the first time, it
initialises a pool of pipes to be used by workers.  The first worker, also used
as a templates process, is spawned (forked and exec) into the
L<Socket::More::Resolver::Worker>.

Detection of the event system is performed in the parent process, and read
monitoring in setup on the 

Subsequent importing of the
module does not load additional.







=head1 COMPARISION TO OTHER MODULES

L<Net::DNS::Native>

  Use Internal threads
  Awkward interface for integration into event loop
  Returns file handles for each resolution request


  
